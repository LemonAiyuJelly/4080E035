### 1.LED0~ LED 10 來回亮一次 <br> 2.從中間的LED7, LED8 開始往兩旁亮，然後在往回中間亮一次。
```C
#define NUM 25 // 首先定義LED的數目
int leds[NUM] = {
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, D14, D15};

void setup() {               
  for(int i = 0; i < NUM; i++){
    pinMode(leds[i], OUTPUT);
    digitalWrite(leds[i], HIGH);
  }    
}

void loop() {
  int cnt=0;

  for(int i = 0; i < 11; i++){
    digitalWrite(leds[i], LOW);
    delay(500);
    digitalWrite(leds[i], HIGH);
  }
  for(int i = 9; i >= 0; i--){
    digitalWrite(leds[i], LOW);
    delay(500);
    digitalWrite(leds[i], HIGH);
  }

  for (int i=0; i<8; i++)
  {
    digitalWrite(leds[8+i], LOW);
    digitalWrite(leds[7-i], LOW);
    delay(500);
    digitalWrite(leds[8+i], HIGH);
    digitalWrite(leds[7-i], HIGH);
  }
  for (int i=1; i<8; i++)
  {
    digitalWrite(leds[i], LOW);
    digitalWrite(leds[15-i], LOW);
    delay(500);
    digitalWrite(leds[i], HIGH);
    digitalWrite(leds[15-i], HIGH);
  }
}
```
 (七段顯示器 最左digital 1, 最右digital 4, だから)
### 1.從按鈕 1 到按鈕 4 (`Button1~4`) 對應到 4 個 七段顯示器分別產生 2 、 0 、 2 、 1 。 <br> 2.七段顯示器能做出數字 8 單字左移 <br> 3.按下按鈕 1 到按鈕 4 (`Button1~4`) 在顯示器上顯示 1~4 ，讓顯示的字出現在顯示器上依 按下的順序由左往右排列，最後按下的按鍵其代表的數字顯示於最右邊的七段顯示器上 (digit 4)
#### Q2-1.ino
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
if(!digitalRead(BUTTON1))
{
WriteNumberToSegment(0 , 2);
}  
if(!digitalRead(BUTTON2))
{
WriteNumberToSegment(1 ,0);
} 
if(!digitalRead(BUTTON3))
{
WriteNumberToSegment(2 , 2);
}  
if(!digitalRead(BUTTON4))
{
WriteNumberToSegment(3 , 1);
}  
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
### 2.七段顯示器能做出數字8 單字左移
#### Q2-2.ino 
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
  for(int j=0; j<4; j++){
  WriteNumberToSegment(3-j,8); //改左移，右移直接放j , 要顯是甚麼數字由第二位置決定,為要放置的字形碼
  delay(100);
  }
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
#### [若要跑全部字型碼請參考連結 Q2-2.ino](https://github.com/ChengHan16/Cs4high_4080E036/blob/master/%E5%BE%AE%E7%AE%97%E6%A9%9F%E5%8E%9F%E7%90%86%E8%88%87%E5%AF%A6%E7%BF%92%E3%80%8A109-2%E3%80%8B/AC%E6%8A%80%E8%A1%93%E8%83%BD%E5%8A%9B%E6%AA%A2%E5%AE%9A/%E3%80%8A2%E3%80%8B04-14%20ACET-%E5%AF%A6%E4%BD%9C%E9%A1%8C-Q2.md)
```C
  //左移
  //若左邊要先亮,將第一位置的3210相反改過來
  WriteNumberToSegment(3,8);
  delay(100);
  WriteNumberToSegment(2,8);
  delay(100);
  WriteNumberToSegment(1,8);
  delay(100);
  WriteNumberToSegment(0,8);
  delay(100);
```
### 3.按下按鈕 1 到按鈕 4 `(Button1~4)` 在顯示器上顯示 1~4 ，讓顯示的字出現在顯示器上依 按下的順序由左往右排列，最後按下的按鍵其代表的數字顯示於最右邊的七段顯示器上 (digit 4)
#### Q2-3.ino
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      delay(10);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
    }
    if(!digitalRead(BUTTON2)){
      delay(10);
        if(!digitalRead(BUTTON2))
        {
          shiftbuf(databuf,SEGMENT_MAP[2]);
          while(!digitalRead(BUTTON2));
        }
    }
    if(!digitalRead(BUTTON3)){
      delay(10);
        if(!digitalRead(BUTTON3))
        {
          shiftbuf(databuf,SEGMENT_MAP[3]);
          while(!digitalRead(BUTTON3));
        }
    }
    if(!digitalRead(BUTTON4)){
      delay(10);
        if(!digitalRead(BUTTON4))
        {
          shiftbuf(databuf,SEGMENT_MAP[4]);
          while(!digitalRead(BUTTON4));
        }
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
#### 也可這樣
```C
*buf=*(buf+1);
*(buf+1)=*(buf+2);
*(buf+2)=*(buf+3);
*(buf+3) = data;
```
### 1. <br> &thinsp;&thinsp; 執行按鈕 1~ A 時 LCD 顯示” 1 、 2 、 3 、 A  <br> &thinsp;&thinsp; 執行按鈕 4 B 時 LCD 顯示 4 、 5 、 6 、 B  <br> &thinsp;&thinsp; 執行按鈕 7 C 時 LCD 顯示 7 、 8 、 9 、 C  <br> &thinsp;&thinsp; 執行按鈕 `*`、 0 、`#` 、 D 時 LC D 顯示” `*`、 0 、`#` 、 D 
### 2. ADP-CORVETTE F1 的 LC D 顯示： 20 20 年 1 2 月 24 日 1X 時 XX 分及 XX 秒 即時時鐘 的格式。
#### Q3-1.ino
```C
#include <LiquidCrystal.h>

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);
char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
byte Row=0, Col=0;

void setup() {
 
  pinMode(10, INPUT);                             
  pinMode(11, INPUT_PULLUP); 
  pinMode(12, INPUT_PULLUP); 
  pinMode(13, INPUT_PULLUP);
  pinMode(A0, OUTPUT);
  pinMode(A1, OUTPUT); 
  pinMode(A2, OUTPUT);
  pinMode(A3, OUTPUT); 

  digitalWrite(A0,HIGH);
  digitalWrite(A1,HIGH);
  digitalWrite(A2,HIGH);
  digitalWrite(A3,HIGH);
  lcd.begin(16, 2);            
  lcd.setCursor(0,0);
  for(int i=0; i<3;i++)
  {
    lcd.print("Key Martrix Test");
    delay(1000);
    lcd.clear();
    delay(400);
  }
} 

void loop() {
  static int keypressedcount=0;
  byte keyindex=0;
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*4+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      lcd.clear();
      lcd.setCursor(0,0);
      lcd.print(KeyValue[keyindex]);
      digitalWrite(A0,LOW);              //--可移除
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW) ||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;   //--可移除
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }

  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }

  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }

  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
```
#### 七段矩陣
```C
#define LATCH_DIO D15 //使移位暫存器的內容輸出到輸出腳位
#define CLK_DIO D14 //移動位移站存器的內容
#define DATA_DIO 2 //移位暫存器的資料輸入內容

//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
const byte KeyMap[]={0x06,0x5b,0x4F,0X77,
                     0x66,0x6D,0x7D,0x7c,
                     0x27,0X7F,0X67,0x39,
                     0x79,0x3F,0x71,0X5e, 0};
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
byte Row=0, Col=0;


void setup() {
  // put your setup code here, to run once:
  pinMode(LATCH_DIO,OUTPUT);
  pinMode(CLK_DIO,OUTPUT);
  pinMode(DATA_DIO,OUTPUT);
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D) //*->E, #->F
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  for(int i=0; i<4; i++)
    WriteNumberToSegment(i, 16);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0; //被按下的按鍵在陣列中的位置
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) //第一次掃描案件，如果顯示有按鍵被按下繼續檢查第二次
  {
    keyindex=(Row-1)*4+Col-1; //第二次掃描如果顯示有按鍵被按下，
                              //下且與第一次位置一樣表示非雜訊產生而是真正有按下按鍵。
    delay(10); //按下按鍵delay幾秒後才送出訊號
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      digitalWrite(A0,LOW);
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW)||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;  
      WriteNumberToSegment(3, keyindex);  
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, KeyMap[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
#### Q3-2.ino
```C
#include <LiquidCrystal.h>
#include <RTC.h>
 
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 5;
const byte hours = 14;
const byte day = 17;

void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2);

     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
}

void loop() {
     lcd.clear();
     lcd.print("2021/6/");
     lcd.print(RTC.getday());
     lcd.print(",");
     //lcd.setCursor(0, 1);

     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
        
     delay(1000);
}
```
### 1.ADP-CORVETTE F1 的多功能板上蜂鳴器產生振動， 共 發 出 6 次聲音，第 1 次時間 1秒，每下次發出聲音時間增加一秒。 <br> 2.可依按鍵發出正確音符聲音，1 、 2 、 3 、 A 、4 、 5 、 6 、 B 分別代表 Do 、 Re 、 Mi 、 Fa 、Sol 、 La 、 Si 、 Do_H) 。 <br> 3.|1 1 5 5| 6 6 5 --| 4 4 3 3|2 2 1 --| 演奏小星星，第 2 、 4 小節最後是 代表 2 拍。
#### Q4-1.ino
```C
int speakerPin = D3;
char notes[] = "ccggaagffeeddc";
unsigned long beats[] = {1,1,1,1,1,1,2,1,1,1,1,1,1,2,4};
int musictones[] = {261, 294, 330, 349, 392, 440, 494, 523};
int length = sizeof(notes);
int tempo = 300;

void setup() {
  pinMode(speakerPin,OUTPUT);
}

void loop() {
    for(int i=0; i<6; i++){
      tone(speakerPin, 1000, duration);
      delay((i+1)*1000);
      noTone(speakerPin);
    }
  delay(3000);
}
```
```c

void setup() {
  pinMode(D3, OUTPUT);} 


void loop() {
  for (int i=1;i<=6;i++){
    digitalWrite(D3,HIGH);
  delay(1000*i);
  digitalWrite(D3,LOW);
  delay(1000);
  }
  }
```
#### Q4-2.ino
```C
/*******************************************************
This program will play as a piano.
********************************************************/
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
/*
 * '1' -> Do  * '2' -> Sol
 * '4' -> Re  * '5' -> La_H
 * '7' -> Mi  * '8' -> Si_H 
 * '*' -> Fa  * '0' -> Do_H
 */

//                     ={Do, Re, Mi, Fa, Sol, La_H, Si_H, Do_H}
unsigned int KeyValue[]={Do, Sol, Re, La_H, Mi, Si_H, Fa, Do_H};
//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
byte Row=0, Col=0;

void playNote(int OutputPin, unsigned int Note, unsigned long duration) {
  // 播放音符對應的頻率
     tone(OutputPin, Note, duration);
  //下方的 delay() 及 noTone ()，測試過後一定要有這兩行，整體的撥放出來的東西才不會亂掉，可能是因為 Arduino 送出tone () 頻率後會馬上接著執行下個指令，不會等聲音播完，導致撥出的聲音混合而亂掉
     delay(duration*1.1);
   noTone(OutputPin);
}

void setup() {
  // put your setup code here, to run once:
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D)
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  digitalWrite(A0,HIGH);
  digitalWrite(A1,HIGH);
  digitalWrite(A2,HIGH);
  digitalWrite(A3,HIGH);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0;
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*2+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*2+Col-1))
    {
      playNote(D3,  KeyValue[keyindex], 300); 
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  /*
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  */
  return(false);
}
```
#### Q4-3.ino
```C
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -| 
//|5 5 4 4| 3 3 2 -|5 5 4 4|3 3 2 -|
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -|
unsigned int melody[]={Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do, 
                       Sol, Sol, Fa, Fa, Mi, Mi, Re, Sol, Sol, Fa, Fa, Mi, Mi, Re,
                       Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do};
unsigned int beat[]={1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2};
int speakerPin = D3;
// 依照簡譜的順序，填入代表的音符，空白代表休止符
unsigned int notes[] = {Do, Re, Mi, Fa, Sol, La_H, Si_H, Do_H};
// 利用 sizeof()，算出總共要多少音符
int length = sizeof(melody) / sizeof(melody[0]);
// 決定一拍多長，這邊一拍 300 ms
int tempo = 300;

void setup() {
  pinMode(speakerPin, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  // 利用 for 來播放我們設定的歌曲，一個音一個音撥放
  for (int i = 0; i < length; i++) {
   // 呼叫 palyNote() 這個 function，將音符轉換成訊號讓蜂鳴器發聲
      playNote(speakerPin, melody[i], tempo*beat[i]);
      Serial.print(notes[i]);Serial.println("Hz");
    // 每個音符之間的間隔，這邊設定的長短會有連音 or 斷音的效果
    //delay(tempo/10);
  }
  Serial.println("************************************");
  delay(2000);
}

void playNote(int OutputPin, unsigned int pitch, unsigned long duration) {
  // 播放音符對應的頻率
     tone(OutputPin,pitch, duration);
  //下方的 delay() 及 noTone ()，測試過後一定要有這兩行，整體的撥放出來的東西才不會亂掉，可能是因為 Arduino 送出tone () 頻率後會馬上接著執行下個指令，不會等聲音播完，導致撥出的聲音混合而亂掉
     delay(duration*1.2);
   noTone(OutputPin);
}
```
---
🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷
### 🔷───🔷───🔷───🔷───🔷
🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷───🔷
# 利用 BTN按鈕 亮起 LED燈
```C
const byte LED[] = {LED1,LED2,LED3,LED4};
const byte BTN[] = {BT1,BT2,BT3,BT4};

void setup() {
  for(int i=0 ; i<4 ; i++){
    pinMode(LED[i],OUTPUT);
    digitalWrite(LED[i],LOW);
  }
  for(int i=0 ; i<4 ; i++){
    pinMode(BTN[i],INPUT);
  }
}

void loop() {
    for(int i=0 ; i<4 ; i++){
      if(!digitalRead(BTN[i])){

        for(int j=0 ; j<4 ; j++)
          digitalWrite(LED[j],LOW); //要持續亮就刪除此行
         digitalWrite(LED[i],HIGH);
         break;
      }
    }
    delay(20);
}
```

# 用矩陣按鈕顯示七段顯示器
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2

//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
const byte KeyMap[]={0x06,0x5b,0x4F,0X77,
                     0x66,0x6D,0x7D,0x7c,
                     0x27,0X7F,0X67,0x39,
                     0x79,0x3F,0x71,0X5e, 0};
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
byte Row=0, Col=0;

void setup() {
  // put your setup code here, to run once:
  pinMode(LATCH_DIO,OUTPUT);
  pinMode(CLK_DIO,OUTPUT);
  pinMode(DATA_DIO,OUTPUT);
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D) //*->E, #->F
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  for(int i=0; i<4; i++)
    WriteNumberToSegment(i, 16);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0;
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*4+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      digitalWrite(A0,LOW);
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW)||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;  
      WriteNumberToSegment(3, keyindex);  
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, KeyMap[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```

# 按下矩陣鍵盤使七段顯示器顯示 '1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'
```C
#define LATCH_DIO D15 //使移位暫存器的內容輸出到輸出腳位
#define CLK_DIO D14 //移動位移站存器的內容
#define DATA_DIO 2 //移位暫存器的資料輸入內容

//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
const byte KeyMap[]={0x06,0x5b,0x4F,0X77,
                     0x66,0x6D,0x7D,0x7c,
                     0x27,0X7F,0X67,0x39,
                     0x79,0x3F,0x71,0X5e, 0};
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
byte Row=0, Col=0;


void setup() {
  // put your setup code here, to run once:
  pinMode(LATCH_DIO,OUTPUT);
  pinMode(CLK_DIO,OUTPUT);
  pinMode(DATA_DIO,OUTPUT);
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D) //*->E, #->F
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  for(int i=0; i<4; i++)
    WriteNumberToSegment(i, 16);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0; //被按下的按鍵在陣列中的位置
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) //第一次掃描案件，如果顯示有按鍵被按下繼續檢查第二次
  {
    keyindex=(Row-1)*4+Col-1; //第二次掃描如果顯示有按鍵被按下，
                              //下且與第一次位置一樣表示非雜訊產生而是真正有按下按鍵。
    delay(10); //按下按鍵delay幾秒後才送出訊號
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      digitalWrite(A0,LOW);
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW)||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;  
      WriteNumberToSegment(3, keyindex);  
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, KeyMap[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```

# 使用 BTN1/2/3/4 在 lcd 上顯示文字及按下按鍵時顯示哪顆按鍵按下
```C
#include <LiquidCrystal.h>
LiquidCrystal lcd(8,9,4,5,6,7);

void setup(){
  pinMode(BT1,INPUT);
  pinMode(BT2,INPUT);
  pinMode(BT3,INPUT);
  pinMode(BT4,INPUT);

  lcd.begin(16,2);
  lcd.print("hello,word!");
  lcd.setCursor(0,1);
  lcd.print("Wellcom to KSU!");
}

int buttonState1,buttonState2,buttonState3,buttonState4=0;
int delay_number = 100;

void loop(){
  buttonState1 =  digitalRead(BT1);
  buttonState2 =  digitalRead(BT2);
  buttonState3 =  digitalRead(BT3);
  buttonState4 =  digitalRead(BT4);
  if(buttonState1 == LOW){
    lcd.clear();
    lcd.print("BT1");
      delay(delay_number);
  } 
  else if (buttonState2 == LOW){
    lcd.clear();
    lcd.print("BT2");
      delay(delay_number);
  }
  else if (buttonState3 == LOW){
    lcd.clear();
    lcd.print("BT3");
      delay(delay_number);
  }
  else if (buttonState4 == LOW){
    lcd.clear();
    lcd.print("BT4");
      delay(delay_number);
  }
}
```

# 2021-05-04 (RTC
```C
/*
  LiquidCrystal Library
  The circuit:
 * LCD RS pin to digital pin 8
 * LCD Enable pin to digital pin 9
 * LCD D4 pin to digital pin 4
 * LCD D5 pin to digital pin 5
 * LCD D6 pin to digital pin 6
 * LCD D7 pin to digital pin 7
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
 */

// include the library code:
#include <LiquidCrystal.h>
#include <RTC.h>
 
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 36;
const byte hours = 13;
const byte day = 10;

void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2);

     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
}

void loop() {
     lcd.clear();
     lcd.print("Start Counting...");
     lcd.setCursor(0, 1);
     lcd.print("21/3/");
     lcd.print(RTC.getday());
     lcd.print(",");
     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
        
     delay(1000);
}
```

# AE250 PWM
```C
void alarmClockBeep(int pin){
  tone(pin,1000,100);
  delay(200);
  tone(pin,1000,100);
  delay(200);
  tone(pin,1000,100);
  delay(1000);
}
void setup() {}
void loop(){
  alarmClockBeep(D3);
}
```

# 在七段顯示器上顯示 8 而由右移至左(重複)
```C
/*https://swf.com.tw/?p=715*/
#define LATCH_DIO D15
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C,d,E,F*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39};
/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7, 0xF0};

void setup ()
{
  /* Set DIO pins to outputs */
  pinMode(LATCH_DIO,OUTPUT); //腳位設置OUTPUT 要將7段顯示器繳未送出 
  pinMode(CLK_DIO,OUTPUT);  //移位用的
  pinMode(DATA_DIO,OUTPUT); //送真的位元資料使用的
}
/* Main program */

void loop()
{
  WriteNumberToSegment(3 , 8);
  delay(500);
  WriteNumberToSegment(2 , 8);
  delay(500);
  WriteNumberToSegment(1 , 8);
  delay(500);
  WriteNumberToSegment(0 , 8);
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value) //byte Segment 顯示得自行, byte Value顯示的位置)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]); //根據後面參數資料
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```

# 在七段顯示器上從左而右顯示 0~9
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
for(int i=0  ; i<16; i++){
  for(int j=0; j<4; j++){
  WriteNumberToSegment(j,i);
  delay(500);
  }
}
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# Q2-1.ino
## 在7段顯示器上 分別用 BUTTON 按下後顯示 2 | 0 | 2 | 1 <br> BTN1 最右方(3) 顯示1 <br> BTN2 最右方(2) 顯示2 <br> BTN3 最右方(1) 顯示0 <br> BTN4 最右方(0) 顯示2
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
if(!digitalRead(BUTTON1))
{
WriteNumberToSegment(3 , 1);
}  
if(!digitalRead(BUTTON2))
{
WriteNumberToSegment(2 ,2);
} 
if(!digitalRead(BUTTON3))
{
WriteNumberToSegment(1 , 0);
}  
if(!digitalRead(BUTTON4))
{
WriteNumberToSegment(0 , 2);
}  
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# Q2-2.ino
## 按按鈕後共同顯示 2021
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
if(!digitalRead(BUTTON1) || !digitalRead(BUTTON2) || !digitalRead(BUTTON3) || !digitalRead(BUTTON4))
{
  while(1)
  {
    WriteNumberToSegment(3 , 1);
    delay(2);
    WriteNumberToSegment(2 ,2);
    delay(2);
    WriteNumberToSegment(1 , 0);
    delay(2);
    WriteNumberToSegment(0 , 2);
    delay(2);
  }  
}
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# Q2-3.ino
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={SEGMENT_MAP[8], 0x00, 0x0, 0x0};
void shiftbuf(char *buf, int len)
{
  char temp=*(buf+len-1);
  for(int i=0; i<len-1; i++)
    *(buf+len-1-i) = *(buf+len-2-i);
  buf[0]=temp;   
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<500))
    {
      WriteNumberToSegment(0, databuf[3]);
      delay(2);
      WriteNumberToSegment(1, databuf[2]);
      delay(2);
      WriteNumberToSegment(2, databuf[1]);
      delay(2);
      WriteNumberToSegment(3, databuf[0]);
      delay(2);  
    }
    shiftbuf(databuf, 4);
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
## Q2-2.ino 七段顯示器 數字往左/右移
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
for(int i=0  ; i<16; i++){
  for(int j=0; j<4; j++){
  WriteNumberToSegment(j,i);
  //WriteNumberToSegment(3-j,i); //改左移，右移直接放j
  delay(100);
  }
}
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
## Q2-3.ino 七段顯示器照按鍵 1、2、3、4 往右顯示移動
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      shiftbuf(databuf,SEGMENT_MAP[1]);
    }
    if(!digitalRead(BUTTON2)){
      shiftbuf(databuf,SEGMENT_MAP[2]);
    }
    if(!digitalRead(BUTTON3)){
      shiftbuf(databuf,SEGMENT_MAP[3]);
    }
    if(!digitalRead(BUTTON4)){
      shiftbuf(databuf,SEGMENT_MAP[4]);
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# 解決彈跳問題，按下BTN時會先等按鈕放開後才繼續動作
```C
if(!digitalRead(BUTTON1)){
      delay(20);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
      //shiftbuf(databuf,SEGMENT_MAP[1]);
    }
```
## Q2-3.ino 七段顯示器照按鍵 1、2、3、4 往右顯示移動
## 解決彈跳問題，按下BTN時會先等按鈕放開後才繼續動作
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      delay(20);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
      //shiftbuf(databuf,SEGMENT_MAP[1]);
    }
    if(!digitalRead(BUTTON2)){
      delay(20);
        if(!digitalRead(BUTTON2))
        {
          shiftbuf(databuf,SEGMENT_MAP[2]);
          while(!digitalRead(BUTTON2));
        }
      //shiftbuf(databuf,SEGMENT_MAP[2]);
    }
    if(!digitalRead(BUTTON3)){
      delay(20);
        if(!digitalRead(BUTTON3))
        {
          shiftbuf(databuf,SEGMENT_MAP[3]);
          while(!digitalRead(BUTTON3));
        }
      //shiftbuf(databuf,SEGMENT_MAP[3]);
    }
    if(!digitalRead(BUTTON4)){
      delay(20);
        if(!digitalRead(BUTTON4))
        {
          shiftbuf(databuf,SEGMENT_MAP[4]);
          while(!digitalRead(BUTTON4));
        }
      //shiftbuf(databuf,SEGMENT_MAP[4]);
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
## Q2-3.ino 七段顯示器照按鍵 1、2、3、4 往右顯示移動
## 解決彈跳問題，按下BTN時會先等按鈕放開後才繼續動作
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      delay(20);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
      //shiftbuf(databuf,SEGMENT_MAP[1]);
    }
    if(!digitalRead(BUTTON2)){
      delay(20);
        if(!digitalRead(BUTTON2))
        {
          shiftbuf(databuf,SEGMENT_MAP[2]);
          while(!digitalRead(BUTTON2));
        }
      //shiftbuf(databuf,SEGMENT_MAP[2]);
    }
    if(!digitalRead(BUTTON3)){
      delay(20);
        if(!digitalRead(BUTTON3))
        {
          shiftbuf(databuf,SEGMENT_MAP[3]);
          while(!digitalRead(BUTTON3));
        }
      //shiftbuf(databuf,SEGMENT_MAP[3]);
    }
    if(!digitalRead(BUTTON4)){
      delay(20);
        if(!digitalRead(BUTTON4))
        {
          shiftbuf(databuf,SEGMENT_MAP[4]);
          while(!digitalRead(BUTTON4));
        }
      //shiftbuf(databuf,SEGMENT_MAP[4]);
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# `LCD_RTC.ino`
```C
/*
  LiquidCrystal Library
  The circuit:
 * LCD RS pin to digital pin 8
 * LCD Enable pin to digital pin 9
 * LCD D4 pin to digital pin 4
 * LCD D5 pin to digital pin 5
 * LCD D6 pin to digital pin 6
 * LCD D7 pin to digital pin 7
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
 */

// include the library code:
#include <LiquidCrystal.h>
#include <RTC.h>
 
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 5;
const byte hours = 14;
const byte day = 5;

void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2); //(行,列)

     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
}

void loop() {
     lcd.clear();
     lcd.print("2021/05/");
     lcd.print(RTC.getday());
     lcd.print(",");
     lcd.setCursor(0, 1);
     
     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
     
     delay(1000);
}
```
# 移動 lcm '考'
# `LCD_RTCalarm.ino`
```C
/*
  LiquidCrystal Library
  The circuit:
 * LCD RS pin to digital pin 8
 * LCD Enable pin to digital pin 9
 * LCD D4 pin to digital pin 4
 * LCD D5 pin to digital pin 5
 * LCD D6 pin to digital pin 6
 * LCD D7 pin to digital pin 7
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
 */

// include the library code:
#include <LiquidCrystal.h>
#include <RTC.h>
//#include "rtc_drv.h"

/* RTC driver */
//RTC_Driver RTC_DRV = {DEV_RTC, 0};
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 4;
const byte hours = 16;
const byte day = 15;
byte alarmminutes = 4;
byte alarmseconds = 10;
void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2);
     Serial.begin(115200);
     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
     RTC.setalarmcallbackfunc(alarm);
     RTC.setalarmtime(hours, minutes, alarmseconds);
     RTC.attachalarmint();
}

void loop() {
     lcd.clear();
     //lcd.print("Start Counting...");
     lcd.setCursor(0, 0);
     lcd.print("2021/5/");
     lcd.print(RTC.getday());
     lcd.print(",");
     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds( ));
     delay(1000);
}

void alarm()
{
     lcd.setCursor(0, 1);
     lcd.print("                   ");
     lcd.setCursor(0, 1);
     lcd.print("alarm "); 
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
     delay(1000);
     alarmseconds += 5;
     if (alarmseconds >= 60)
        alarmminutes = RTC.getminutes()+1;
     else
        alarmminutes = RTC.getminutes(); 
     alarmseconds %= 60;
     RTC.setalarmtime(hours, alarmminutes, alarmseconds);        
     RTC.clearalarmst();  
}
```
## ● `Q4-2`
```C
/*******************************************************
This program will play as a piano.
********************************************************/
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
/*
 * '1' -> Do  * '2' -> Sol
 * '4' -> Re  * '5' -> La_H
 * '7' -> Mi  * '8' -> Si_H 
 * '*' -> Fa  * '0' -> Do_H
 */
unsigned int KeyValue[]={Do, Sol, Re, La_H, Mi, Si_H, Fa, Do_H};
//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
byte Row=0, Col=0;

void playNote(int OutputPin, unsigned int Note, unsigned long duration) {
  // 播放音符對應的頻率
     tone(OutputPin, Note, duration);
  //下方的 delay() 及 noTone ()，測試過後一定要有這兩行，整體的撥放出來的東西才不會亂掉，可能是因為 Arduino 送出tone () 頻率後會馬上接著執行下個指令，不會等聲音播完，導致撥出的聲音混合而亂掉
     delay(duration*1.1);
   noTone(OutputPin);
}

void setup() {
  // put your setup code here, to run once:
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D)
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  digitalWrite(A0,HIGH);
  digitalWrite(A1,HIGH);
  digitalWrite(A2,HIGH);
  digitalWrite(A3,HIGH);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0;
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*2+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*2+Col-1))
    {
      playNote(D3,  KeyValue[keyindex], 300); 
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  /*
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  */
  return(false);
}
```
## ● `Q4-3`
```C
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -| 
//|5 5 4 4| 3 3 2 -|5 5 4 4|3 3 2 -|
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -|
unsigned int melody[]={Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do, 
                       Sol, Sol, Fa, Fa, Mi, Mi, Re, Sol, Sol, Fa, Fa, Mi, Mi, Re,
                       Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do};
unsigned int beat[]={1,1,1,1,1,1,2,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,2,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,2,1,1,1,1,1,1,2};
int speakerPin = D3;
// 依照簡譜的順序，填入代表的音符，空白代表休止符
unsigned int notes[] = {Do, Re, Mi, Fa, Sol, La_H, Si_H, Do_H};
// 利用 sizeof()，算出總共要多少音符
int length = sizeof(melody) / sizeof(melody[0]);
// 決定一拍多長，這邊一拍 300 ms
int tempo = 300;

void setup() {
  pinMode(speakerPin, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  // 利用 for 來播放我們設定的歌曲，一個音一個音撥放
  for (int i = 0; i < length; i++) {
   // 呼叫 palyNote() 這個 function，將音符轉換成訊號讓蜂鳴器發聲
      playNote(speakerPin, melody[i], tempo*beat[i]);
      Serial.print(notes[i]);Serial.println("Hz");
    // 每個音符之間的間隔，這邊設定的長短會有連音 or 斷音的效果
    //delay(tempo/10);
  }
  Serial.println("************************************");
  delay(2000);
}

void playNote(int OutputPin, unsigned int pitch, unsigned long duration) {
  // 播放音符對應的頻率
     tone(OutputPin,pitch, duration);
  //下方的 delay() 及 noTone ()，測試過後一定要有這兩行，整體的撥放出來的東西才不會亂掉，可能是因為 Arduino 送出tone () 頻率後會馬上接著執行下個指令，不會等聲音播完，導致撥出的聲音混合而亂掉
     delay(duration*1.2);
   noTone(OutputPin);
}

```
## ● `ambulance`
```C
void setup() {
    
}

void loop() {
  ambulenceSiren(D3);
}

void ambulenceSiren(int pin) {
  tone(pin, 400);        
  delay(500);
  tone(pin, 800);        
  delay(500);
  noTone(pin);
  }
```
