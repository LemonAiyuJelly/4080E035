### 1.LED0~ LED 10 ä¾†å›äº®ä¸€æ¬¡ <br> 2.å¾ä¸­é–“çš„LED7, LED8 é–‹å§‹å¾€å…©æ—äº®ï¼Œç„¶å¾Œåœ¨å¾€å›ä¸­é–“äº®ä¸€æ¬¡ã€‚
```C
#define NUM 25 // é¦–å…ˆå®šç¾©LEDçš„æ•¸ç›®
int leds[NUM] = {
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, D14, D15};

void setup() {               
  for(int i = 0; i < NUM; i++){
    pinMode(leds[i], OUTPUT);
    digitalWrite(leds[i], HIGH);
  }    
}

void loop() {
  int cnt=0;

  for(int i = 0; i < 11; i++){
    digitalWrite(leds[i], LOW);
    delay(500);
    digitalWrite(leds[i], HIGH);
  }
  for(int i = 9; i >= 0; i--){
    digitalWrite(leds[i], LOW);
    delay(500);
    digitalWrite(leds[i], HIGH);
  }

  for (int i=0; i<8; i++)
  {
    digitalWrite(leds[8+i], LOW);
    digitalWrite(leds[7-i], LOW);
    delay(500);
    digitalWrite(leds[8+i], HIGH);
    digitalWrite(leds[7-i], HIGH);
  }
  for (int i=1; i<8; i++)
  {
    digitalWrite(leds[i], LOW);
    digitalWrite(leds[15-i], LOW);
    delay(500);
    digitalWrite(leds[i], HIGH);
    digitalWrite(leds[15-i], HIGH);
  }
}
```
 (ä¸ƒæ®µé¡¯ç¤ºå™¨ æœ€å·¦digital 1, æœ€å³digital 4, ã ã‹ã‚‰)
### 1.å¾æŒ‰éˆ• 1 åˆ°æŒ‰éˆ• 4 (`Button1~4`) å°æ‡‰åˆ° 4 å€‹ ä¸ƒæ®µé¡¯ç¤ºå™¨åˆ†åˆ¥ç”¢ç”Ÿ 2 ã€ 0 ã€ 2 ã€ 1 ã€‚ <br> 2.ä¸ƒæ®µé¡¯ç¤ºå™¨èƒ½åšå‡ºæ•¸å­— 8 å–®å­—å·¦ç§» <br> 3.æŒ‰ä¸‹æŒ‰éˆ• 1 åˆ°æŒ‰éˆ• 4 (`Button1~4`) åœ¨é¡¯ç¤ºå™¨ä¸Šé¡¯ç¤º 1~4 ï¼Œè®“é¡¯ç¤ºçš„å­—å‡ºç¾åœ¨é¡¯ç¤ºå™¨ä¸Šä¾ æŒ‰ä¸‹çš„é †åºç”±å·¦å¾€å³æ’åˆ—ï¼Œæœ€å¾ŒæŒ‰ä¸‹çš„æŒ‰éµå…¶ä»£è¡¨çš„æ•¸å­—é¡¯ç¤ºæ–¼æœ€å³é‚Šçš„ä¸ƒæ®µé¡¯ç¤ºå™¨ä¸Š (digit 4)
#### Q2-1.ino
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
if(!digitalRead(BUTTON1))
{
WriteNumberToSegment(0 , 2);
}  
if(!digitalRead(BUTTON2))
{
WriteNumberToSegment(1 ,0);
} 
if(!digitalRead(BUTTON3))
{
WriteNumberToSegment(2 , 2);
}  
if(!digitalRead(BUTTON4))
{
WriteNumberToSegment(3 , 1);
}  
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
### 2.ä¸ƒæ®µé¡¯ç¤ºå™¨èƒ½åšå‡ºæ•¸å­—8 å–®å­—å·¦ç§»
#### Q2-2.ino 
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
  for(int j=0; j<4; j++){
  WriteNumberToSegment(3-j,8); //æ”¹å·¦ç§»ï¼Œå³ç§»ç›´æ¥æ”¾j , è¦é¡¯æ˜¯ç”šéº¼æ•¸å­—ç”±ç¬¬äºŒä½ç½®æ±ºå®š,ç‚ºè¦æ”¾ç½®çš„å­—å½¢ç¢¼
  delay(100);
  }
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
#### [è‹¥è¦è·‘å…¨éƒ¨å­—å‹ç¢¼è«‹åƒè€ƒé€£çµ Q2-2.ino](https://github.com/ChengHan16/Cs4high_4080E036/blob/master/%E5%BE%AE%E7%AE%97%E6%A9%9F%E5%8E%9F%E7%90%86%E8%88%87%E5%AF%A6%E7%BF%92%E3%80%8A109-2%E3%80%8B/AC%E6%8A%80%E8%A1%93%E8%83%BD%E5%8A%9B%E6%AA%A2%E5%AE%9A/%E3%80%8A2%E3%80%8B04-14%20ACET-%E5%AF%A6%E4%BD%9C%E9%A1%8C-Q2.md)
```C
  //å·¦ç§»
  //è‹¥å·¦é‚Šè¦å…ˆäº®,å°‡ç¬¬ä¸€ä½ç½®çš„3210ç›¸åæ”¹éä¾†
  WriteNumberToSegment(3,8);
  delay(100);
  WriteNumberToSegment(2,8);
  delay(100);
  WriteNumberToSegment(1,8);
  delay(100);
  WriteNumberToSegment(0,8);
  delay(100);
```
### 3.æŒ‰ä¸‹æŒ‰éˆ• 1 åˆ°æŒ‰éˆ• 4 `(Button1~4)` åœ¨é¡¯ç¤ºå™¨ä¸Šé¡¯ç¤º 1~4 ï¼Œè®“é¡¯ç¤ºçš„å­—å‡ºç¾åœ¨é¡¯ç¤ºå™¨ä¸Šä¾ æŒ‰ä¸‹çš„é †åºç”±å·¦å¾€å³æ’åˆ—ï¼Œæœ€å¾ŒæŒ‰ä¸‹çš„æŒ‰éµå…¶ä»£è¡¨çš„æ•¸å­—é¡¯ç¤ºæ–¼æœ€å³é‚Šçš„ä¸ƒæ®µé¡¯ç¤ºå™¨ä¸Š (digit 4)
#### Q2-3.ino
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      delay(10);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
    }
    if(!digitalRead(BUTTON2)){
      delay(10);
        if(!digitalRead(BUTTON2))
        {
          shiftbuf(databuf,SEGMENT_MAP[2]);
          while(!digitalRead(BUTTON2));
        }
    }
    if(!digitalRead(BUTTON3)){
      delay(10);
        if(!digitalRead(BUTTON3))
        {
          shiftbuf(databuf,SEGMENT_MAP[3]);
          while(!digitalRead(BUTTON3));
        }
    }
    if(!digitalRead(BUTTON4)){
      delay(10);
        if(!digitalRead(BUTTON4))
        {
          shiftbuf(databuf,SEGMENT_MAP[4]);
          while(!digitalRead(BUTTON4));
        }
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
#### ä¹Ÿå¯é€™æ¨£
```C
*buf=*(buf+1);
*(buf+1)=*(buf+2);
*(buf+2)=*(buf+3);
*(buf+3) = data;
```
### 1. <br> &thinsp;&thinsp; åŸ·è¡ŒæŒ‰éˆ• 1~ A æ™‚ LCD é¡¯ç¤ºâ€ 1 ã€ 2 ã€ 3 ã€ A  <br> &thinsp;&thinsp; åŸ·è¡ŒæŒ‰éˆ• 4 B æ™‚ LCD é¡¯ç¤º 4 ã€ 5 ã€ 6 ã€ B  <br> &thinsp;&thinsp; åŸ·è¡ŒæŒ‰éˆ• 7 C æ™‚ LCD é¡¯ç¤º 7 ã€ 8 ã€ 9 ã€ C  <br> &thinsp;&thinsp; åŸ·è¡ŒæŒ‰éˆ• `*`ã€ 0 ã€`#` ã€ D æ™‚ LC D é¡¯ç¤ºâ€ `*`ã€ 0 ã€`#` ã€ D 
### 2. ADP-CORVETTE F1 çš„ LC D é¡¯ç¤ºï¼š 20 20 å¹´ 1 2 æœˆ 24 æ—¥ 1X æ™‚ XX åˆ†åŠ XX ç§’ å³æ™‚æ™‚é˜ çš„æ ¼å¼ã€‚
#### Q3-1.ino
```C
#include <LiquidCrystal.h>

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);
char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
byte Row=0, Col=0;

void setup() {
 
  pinMode(10, INPUT);                             
  pinMode(11, INPUT_PULLUP); 
  pinMode(12, INPUT_PULLUP); 
  pinMode(13, INPUT_PULLUP);
  pinMode(A0, OUTPUT);
  pinMode(A1, OUTPUT); 
  pinMode(A2, OUTPUT);
  pinMode(A3, OUTPUT); 

  digitalWrite(A0,HIGH);
  digitalWrite(A1,HIGH);
  digitalWrite(A2,HIGH);
  digitalWrite(A3,HIGH);
  lcd.begin(16, 2);            
  lcd.setCursor(0,0);
  for(int i=0; i<3;i++)
  {
    lcd.print("Key Martrix Test");
    delay(1000);
    lcd.clear();
    delay(400);
  }
} 

void loop() {
  static int keypressedcount=0;
  byte keyindex=0;
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*4+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      lcd.clear();
      lcd.setCursor(0,0);
      lcd.print(KeyValue[keyindex]);
      digitalWrite(A0,LOW);              //--å¯ç§»é™¤
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW) ||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;   //--å¯ç§»é™¤
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }

  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }

  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }

  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);

  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }

  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
```
#### ä¸ƒæ®µçŸ©é™£
```C
#define LATCH_DIO D15 //ä½¿ç§»ä½æš«å­˜å™¨çš„å…§å®¹è¼¸å‡ºåˆ°è¼¸å‡ºè…³ä½
#define CLK_DIO D14 //ç§»å‹•ä½ç§»ç«™å­˜å™¨çš„å…§å®¹
#define DATA_DIO 2 //ç§»ä½æš«å­˜å™¨çš„è³‡æ–™è¼¸å…¥å…§å®¹

//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
const byte KeyMap[]={0x06,0x5b,0x4F,0X77,
                     0x66,0x6D,0x7D,0x7c,
                     0x27,0X7F,0X67,0x39,
                     0x79,0x3F,0x71,0X5e, 0};
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
byte Row=0, Col=0;


void setup() {
  // put your setup code here, to run once:
  pinMode(LATCH_DIO,OUTPUT);
  pinMode(CLK_DIO,OUTPUT);
  pinMode(DATA_DIO,OUTPUT);
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D) //*->E, #->F
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  for(int i=0; i<4; i++)
    WriteNumberToSegment(i, 16);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0; //è¢«æŒ‰ä¸‹çš„æŒ‰éµåœ¨é™£åˆ—ä¸­çš„ä½ç½®
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) //ç¬¬ä¸€æ¬¡æƒææ¡ˆä»¶ï¼Œå¦‚æœé¡¯ç¤ºæœ‰æŒ‰éµè¢«æŒ‰ä¸‹ç¹¼çºŒæª¢æŸ¥ç¬¬äºŒæ¬¡
  {
    keyindex=(Row-1)*4+Col-1; //ç¬¬äºŒæ¬¡æƒæå¦‚æœé¡¯ç¤ºæœ‰æŒ‰éµè¢«æŒ‰ä¸‹ï¼Œ
                              //ä¸‹ä¸”èˆ‡ç¬¬ä¸€æ¬¡ä½ç½®ä¸€æ¨£è¡¨ç¤ºéé›œè¨Šç”¢ç”Ÿè€Œæ˜¯çœŸæ­£æœ‰æŒ‰ä¸‹æŒ‰éµã€‚
    delay(10); //æŒ‰ä¸‹æŒ‰éµdelayå¹¾ç§’å¾Œæ‰é€å‡ºè¨Šè™Ÿ
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      digitalWrite(A0,LOW);
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW)||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;  
      WriteNumberToSegment(3, keyindex);  
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, KeyMap[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
#### Q3-2.ino
```C
#include <LiquidCrystal.h>
#include <RTC.h>
 
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 5;
const byte hours = 14;
const byte day = 17;

void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2);

     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
}

void loop() {
     lcd.clear();
     lcd.print("2021/6/");
     lcd.print(RTC.getday());
     lcd.print(",");
     //lcd.setCursor(0, 1);

     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
        
     delay(1000);
}
```
### 1.ADP-CORVETTE F1 çš„å¤šåŠŸèƒ½æ¿ä¸Šèœ‚é³´å™¨ç”¢ç”ŸæŒ¯å‹•ï¼Œ å…± ç™¼ å‡º 6 æ¬¡è²éŸ³ï¼Œç¬¬ 1 æ¬¡æ™‚é–“ 1ç§’ï¼Œæ¯ä¸‹æ¬¡ç™¼å‡ºè²éŸ³æ™‚é–“å¢åŠ ä¸€ç§’ã€‚ <br> 2.å¯ä¾æŒ‰éµç™¼å‡ºæ­£ç¢ºéŸ³ç¬¦è²éŸ³ï¼Œ1 ã€ 2 ã€ 3 ã€ A ã€4 ã€ 5 ã€ 6 ã€ B åˆ†åˆ¥ä»£è¡¨ Do ã€ Re ã€ Mi ã€ Fa ã€Sol ã€ La ã€ Si ã€ Do_H) ã€‚ <br> 3.|1 1 5 5| 6 6 5 --| 4 4 3 3|2 2 1 --| æ¼”å¥å°æ˜Ÿæ˜Ÿï¼Œç¬¬ 2 ã€ 4 å°ç¯€æœ€å¾Œæ˜¯ ä»£è¡¨ 2 æ‹ã€‚
#### Q4-1.ino
```C
int speakerPin = D3;
char notes[] = "ccggaagffeeddc";
unsigned long beats[] = {1,1,1,1,1,1,2,1,1,1,1,1,1,2,4};
int musictones[] = {261, 294, 330, 349, 392, 440, 494, 523};
int length = sizeof(notes);
int tempo = 300;

void setup() {
  pinMode(speakerPin,OUTPUT);
}

void loop() {
    for(int i=0; i<6; i++){
      tone(speakerPin, 1000, duration);
      delay((i+1)*1000);
      noTone(speakerPin);
    }
  delay(3000);
}
```
```c

void setup() {
  pinMode(D3, OUTPUT);} 


void loop() {
  for (int i=1;i<=6;i++){
    digitalWrite(D3,HIGH);
  delay(1000*i);
  digitalWrite(D3,LOW);
  delay(1000);
  }
  }
```
#### Q4-2.ino
```C
/*******************************************************
This program will play as a piano.
********************************************************/
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
/*
 * '1' -> Do  * '2' -> Sol
 * '4' -> Re  * '5' -> La_H
 * '7' -> Mi  * '8' -> Si_H 
 * '*' -> Fa  * '0' -> Do_H
 */

//                     ={Do, Re, Mi, Fa, Sol, La_H, Si_H, Do_H}
unsigned int KeyValue[]={Do, Sol, Re, La_H, Mi, Si_H, Fa, Do_H};
//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
byte Row=0, Col=0;

void playNote(int OutputPin, unsigned int Note, unsigned long duration) {
  // æ’­æ”¾éŸ³ç¬¦å°æ‡‰çš„é »ç‡
     tone(OutputPin, Note, duration);
  //ä¸‹æ–¹çš„ delay() åŠ noTone ()ï¼Œæ¸¬è©¦éå¾Œä¸€å®šè¦æœ‰é€™å…©è¡Œï¼Œæ•´é«”çš„æ’¥æ”¾å‡ºä¾†çš„æ±è¥¿æ‰ä¸æœƒäº‚æ‰ï¼Œå¯èƒ½æ˜¯å› ç‚º Arduino é€å‡ºtone () é »ç‡å¾Œæœƒé¦¬ä¸Šæ¥è‘—åŸ·è¡Œä¸‹å€‹æŒ‡ä»¤ï¼Œä¸æœƒç­‰è²éŸ³æ’­å®Œï¼Œå°è‡´æ’¥å‡ºçš„è²éŸ³æ··åˆè€Œäº‚æ‰
     delay(duration*1.1);
   noTone(OutputPin);
}

void setup() {
  // put your setup code here, to run once:
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D)
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  digitalWrite(A0,HIGH);
  digitalWrite(A1,HIGH);
  digitalWrite(A2,HIGH);
  digitalWrite(A3,HIGH);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0;
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*2+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*2+Col-1))
    {
      playNote(D3,  KeyValue[keyindex], 300); 
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  /*
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  */
  return(false);
}
```
#### Q4-3.ino
```C
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -| 
//|5 5 4 4| 3 3 2 -|5 5 4 4|3 3 2 -|
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -|
unsigned int melody[]={Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do, 
                       Sol, Sol, Fa, Fa, Mi, Mi, Re, Sol, Sol, Fa, Fa, Mi, Mi, Re,
                       Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do};
unsigned int beat[]={1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2};
int speakerPin = D3;
// ä¾ç…§ç°¡è­œçš„é †åºï¼Œå¡«å…¥ä»£è¡¨çš„éŸ³ç¬¦ï¼Œç©ºç™½ä»£è¡¨ä¼‘æ­¢ç¬¦
unsigned int notes[] = {Do, Re, Mi, Fa, Sol, La_H, Si_H, Do_H};
// åˆ©ç”¨ sizeof()ï¼Œç®—å‡ºç¸½å…±è¦å¤šå°‘éŸ³ç¬¦
int length = sizeof(melody) / sizeof(melody[0]);
// æ±ºå®šä¸€æ‹å¤šé•·ï¼Œé€™é‚Šä¸€æ‹ 300 ms
int tempo = 300;

void setup() {
  pinMode(speakerPin, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  // åˆ©ç”¨ for ä¾†æ’­æ”¾æˆ‘å€‘è¨­å®šçš„æ­Œæ›²ï¼Œä¸€å€‹éŸ³ä¸€å€‹éŸ³æ’¥æ”¾
  for (int i = 0; i < length; i++) {
   // å‘¼å« palyNote() é€™å€‹ functionï¼Œå°‡éŸ³ç¬¦è½‰æ›æˆè¨Šè™Ÿè®“èœ‚é³´å™¨ç™¼è²
      playNote(speakerPin, melody[i], tempo*beat[i]);
      Serial.print(notes[i]);Serial.println("Hz");
    // æ¯å€‹éŸ³ç¬¦ä¹‹é–“çš„é–“éš”ï¼Œé€™é‚Šè¨­å®šçš„é•·çŸ­æœƒæœ‰é€£éŸ³ or æ–·éŸ³çš„æ•ˆæœ
    //delay(tempo/10);
  }
  Serial.println("************************************");
  delay(2000);
}

void playNote(int OutputPin, unsigned int pitch, unsigned long duration) {
  // æ’­æ”¾éŸ³ç¬¦å°æ‡‰çš„é »ç‡
     tone(OutputPin,pitch, duration);
  //ä¸‹æ–¹çš„ delay() åŠ noTone ()ï¼Œæ¸¬è©¦éå¾Œä¸€å®šè¦æœ‰é€™å…©è¡Œï¼Œæ•´é«”çš„æ’¥æ”¾å‡ºä¾†çš„æ±è¥¿æ‰ä¸æœƒäº‚æ‰ï¼Œå¯èƒ½æ˜¯å› ç‚º Arduino é€å‡ºtone () é »ç‡å¾Œæœƒé¦¬ä¸Šæ¥è‘—åŸ·è¡Œä¸‹å€‹æŒ‡ä»¤ï¼Œä¸æœƒç­‰è²éŸ³æ’­å®Œï¼Œå°è‡´æ’¥å‡ºçš„è²éŸ³æ··åˆè€Œäº‚æ‰
     delay(duration*1.2);
   noTone(OutputPin);
}
```
---
ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·
### ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·
ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·â”€â”€â”€ğŸ”·
# åˆ©ç”¨ BTNæŒ‰éˆ• äº®èµ· LEDç‡ˆ
```C
const byte LED[] = {LED1,LED2,LED3,LED4};
const byte BTN[] = {BT1,BT2,BT3,BT4};

void setup() {
  for(int i=0 ; i<4 ; i++){
    pinMode(LED[i],OUTPUT);
    digitalWrite(LED[i],LOW);
  }
  for(int i=0 ; i<4 ; i++){
    pinMode(BTN[i],INPUT);
  }
}

void loop() {
    for(int i=0 ; i<4 ; i++){
      if(!digitalRead(BTN[i])){

        for(int j=0 ; j<4 ; j++)
          digitalWrite(LED[j],LOW); //è¦æŒçºŒäº®å°±åˆªé™¤æ­¤è¡Œ
         digitalWrite(LED[i],HIGH);
         break;
      }
    }
    delay(20);
}
```

# ç”¨çŸ©é™£æŒ‰éˆ•é¡¯ç¤ºä¸ƒæ®µé¡¯ç¤ºå™¨
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2

//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
const byte KeyMap[]={0x06,0x5b,0x4F,0X77,
                     0x66,0x6D,0x7D,0x7c,
                     0x27,0X7F,0X67,0x39,
                     0x79,0x3F,0x71,0X5e, 0};
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
byte Row=0, Col=0;

void setup() {
  // put your setup code here, to run once:
  pinMode(LATCH_DIO,OUTPUT);
  pinMode(CLK_DIO,OUTPUT);
  pinMode(DATA_DIO,OUTPUT);
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D) //*->E, #->F
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  for(int i=0; i<4; i++)
    WriteNumberToSegment(i, 16);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0;
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*4+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      digitalWrite(A0,LOW);
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW)||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;  
      WriteNumberToSegment(3, keyindex);  
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, KeyMap[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```

# æŒ‰ä¸‹çŸ©é™£éµç›¤ä½¿ä¸ƒæ®µé¡¯ç¤ºå™¨é¡¯ç¤º '1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'
```C
#define LATCH_DIO D15 //ä½¿ç§»ä½æš«å­˜å™¨çš„å…§å®¹è¼¸å‡ºåˆ°è¼¸å‡ºè…³ä½
#define CLK_DIO D14 //ç§»å‹•ä½ç§»ç«™å­˜å™¨çš„å…§å®¹
#define DATA_DIO 2 //ç§»ä½æš«å­˜å™¨çš„è³‡æ–™è¼¸å…¥å…§å®¹

//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
const byte KeyMap[]={0x06,0x5b,0x4F,0X77,
                     0x66,0x6D,0x7D,0x7c,
                     0x27,0X7F,0X67,0x39,
                     0x79,0x3F,0x71,0X5e, 0};
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
byte Row=0, Col=0;


void setup() {
  // put your setup code here, to run once:
  pinMode(LATCH_DIO,OUTPUT);
  pinMode(CLK_DIO,OUTPUT);
  pinMode(DATA_DIO,OUTPUT);
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D) //*->E, #->F
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  for(int i=0; i<4; i++)
    WriteNumberToSegment(i, 16);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0; //è¢«æŒ‰ä¸‹çš„æŒ‰éµåœ¨é™£åˆ—ä¸­çš„ä½ç½®
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) //ç¬¬ä¸€æ¬¡æƒææ¡ˆä»¶ï¼Œå¦‚æœé¡¯ç¤ºæœ‰æŒ‰éµè¢«æŒ‰ä¸‹ç¹¼çºŒæª¢æŸ¥ç¬¬äºŒæ¬¡
  {
    keyindex=(Row-1)*4+Col-1; //ç¬¬äºŒæ¬¡æƒæå¦‚æœé¡¯ç¤ºæœ‰æŒ‰éµè¢«æŒ‰ä¸‹ï¼Œ
                              //ä¸‹ä¸”èˆ‡ç¬¬ä¸€æ¬¡ä½ç½®ä¸€æ¨£è¡¨ç¤ºéé›œè¨Šç”¢ç”Ÿè€Œæ˜¯çœŸæ­£æœ‰æŒ‰ä¸‹æŒ‰éµã€‚
    delay(10); //æŒ‰ä¸‹æŒ‰éµdelayå¹¾ç§’å¾Œæ‰é€å‡ºè¨Šè™Ÿ
    if ((keyscan()==true) && (keyindex==(Row-1)*4+Col-1))
    {
      digitalWrite(A0,LOW);
      digitalWrite(A1,LOW);
      digitalWrite(A2,LOW);
      digitalWrite(A3,LOW);
      delayMicroseconds(100);
      while( (digitalRead(10)==LOW) || (digitalRead(11)==LOW)||(digitalRead(12)==LOW) || (digitalRead(13)==LOW))
        ;  
      WriteNumberToSegment(3, keyindex);  
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  return(false);
}
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, KeyMap[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```

# ä½¿ç”¨ BTN1/2/3/4 åœ¨ lcd ä¸Šé¡¯ç¤ºæ–‡å­—åŠæŒ‰ä¸‹æŒ‰éµæ™‚é¡¯ç¤ºå“ªé¡†æŒ‰éµæŒ‰ä¸‹
```C
#include <LiquidCrystal.h>
LiquidCrystal lcd(8,9,4,5,6,7);

void setup(){
  pinMode(BT1,INPUT);
  pinMode(BT2,INPUT);
  pinMode(BT3,INPUT);
  pinMode(BT4,INPUT);

  lcd.begin(16,2);
  lcd.print("hello,word!");
  lcd.setCursor(0,1);
  lcd.print("Wellcom to KSU!");
}

int buttonState1,buttonState2,buttonState3,buttonState4=0;
int delay_number = 100;

void loop(){
  buttonState1 =  digitalRead(BT1);
  buttonState2 =  digitalRead(BT2);
  buttonState3 =  digitalRead(BT3);
  buttonState4 =  digitalRead(BT4);
  if(buttonState1 == LOW){
    lcd.clear();
    lcd.print("BT1");
      delay(delay_number);
  } 
  else if (buttonState2 == LOW){
    lcd.clear();
    lcd.print("BT2");
      delay(delay_number);
  }
  else if (buttonState3 == LOW){
    lcd.clear();
    lcd.print("BT3");
      delay(delay_number);
  }
  else if (buttonState4 == LOW){
    lcd.clear();
    lcd.print("BT4");
      delay(delay_number);
  }
}
```

# 2021-05-04 (RTC
```C
/*
  LiquidCrystal Library
  The circuit:
 * LCD RS pin to digital pin 8
 * LCD Enable pin to digital pin 9
 * LCD D4 pin to digital pin 4
 * LCD D5 pin to digital pin 5
 * LCD D6 pin to digital pin 6
 * LCD D7 pin to digital pin 7
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
 */

// include the library code:
#include <LiquidCrystal.h>
#include <RTC.h>
 
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 36;
const byte hours = 13;
const byte day = 10;

void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2);

     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
}

void loop() {
     lcd.clear();
     lcd.print("Start Counting...");
     lcd.setCursor(0, 1);
     lcd.print("21/3/");
     lcd.print(RTC.getday());
     lcd.print(",");
     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
        
     delay(1000);
}
```

# AE250 PWM
```C
void alarmClockBeep(int pin){
  tone(pin,1000,100);
  delay(200);
  tone(pin,1000,100);
  delay(200);
  tone(pin,1000,100);
  delay(1000);
}
void setup() {}
void loop(){
  alarmClockBeep(D3);
}
```

# åœ¨ä¸ƒæ®µé¡¯ç¤ºå™¨ä¸Šé¡¯ç¤º 8 è€Œç”±å³ç§»è‡³å·¦(é‡è¤‡)
```C
/*https://swf.com.tw/?p=715*/
#define LATCH_DIO D15
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C,d,E,F*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39};
/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7, 0xF0};

void setup ()
{
  /* Set DIO pins to outputs */
  pinMode(LATCH_DIO,OUTPUT); //è…³ä½è¨­ç½®OUTPUT è¦å°‡7æ®µé¡¯ç¤ºå™¨ç¹³æœªé€å‡º 
  pinMode(CLK_DIO,OUTPUT);  //ç§»ä½ç”¨çš„
  pinMode(DATA_DIO,OUTPUT); //é€çœŸçš„ä½å…ƒè³‡æ–™ä½¿ç”¨çš„
}
/* Main program */

void loop()
{
  WriteNumberToSegment(3 , 8);
  delay(500);
  WriteNumberToSegment(2 , 8);
  delay(500);
  WriteNumberToSegment(1 , 8);
  delay(500);
  WriteNumberToSegment(0 , 8);
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value) //byte Segment é¡¯ç¤ºå¾—è‡ªè¡Œ, byte Valueé¡¯ç¤ºçš„ä½ç½®)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]); //æ ¹æ“šå¾Œé¢åƒæ•¸è³‡æ–™
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```

# åœ¨ä¸ƒæ®µé¡¯ç¤ºå™¨ä¸Šå¾å·¦è€Œå³é¡¯ç¤º 0~9
```C
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
for(int i=0  ; i<16; i++){
  for(int j=0; j<4; j++){
  WriteNumberToSegment(j,i);
  delay(500);
  }
}
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# Q2-1.ino
## åœ¨7æ®µé¡¯ç¤ºå™¨ä¸Š åˆ†åˆ¥ç”¨ BUTTON æŒ‰ä¸‹å¾Œé¡¯ç¤º 2 | 0 | 2 | 1 <br> BTN1 æœ€å³æ–¹(3) é¡¯ç¤º1 <br> BTN2 æœ€å³æ–¹(2) é¡¯ç¤º2 <br> BTN3 æœ€å³æ–¹(1) é¡¯ç¤º0 <br> BTN4 æœ€å³æ–¹(0) é¡¯ç¤º2
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
if(!digitalRead(BUTTON1))
{
WriteNumberToSegment(3 , 1);
}  
if(!digitalRead(BUTTON2))
{
WriteNumberToSegment(2 ,2);
} 
if(!digitalRead(BUTTON3))
{
WriteNumberToSegment(1 , 0);
}  
if(!digitalRead(BUTTON4))
{
WriteNumberToSegment(0 , 2);
}  
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# Q2-2.ino
## æŒ‰æŒ‰éˆ•å¾Œå…±åŒé¡¯ç¤º 2021
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
if(!digitalRead(BUTTON1) || !digitalRead(BUTTON2) || !digitalRead(BUTTON3) || !digitalRead(BUTTON4))
{
  while(1)
  {
    WriteNumberToSegment(3 , 1);
    delay(2);
    WriteNumberToSegment(2 ,2);
    delay(2);
    WriteNumberToSegment(1 , 0);
    delay(2);
    WriteNumberToSegment(0 , 2);
    delay(2);
  }  
}
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# Q2-3.ino
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={SEGMENT_MAP[8], 0x00, 0x0, 0x0};
void shiftbuf(char *buf, int len)
{
  char temp=*(buf+len-1);
  for(int i=0; i<len-1; i++)
    *(buf+len-1-i) = *(buf+len-2-i);
  buf[0]=temp;   
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<500))
    {
      WriteNumberToSegment(0, databuf[3]);
      delay(2);
      WriteNumberToSegment(1, databuf[2]);
      delay(2);
      WriteNumberToSegment(2, databuf[1]);
      delay(2);
      WriteNumberToSegment(3, databuf[0]);
      delay(2);  
    }
    shiftbuf(databuf, 4);
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
## Q2-2.ino ä¸ƒæ®µé¡¯ç¤ºå™¨ æ•¸å­—å¾€å·¦/å³ç§»
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
void loop()
{
/* Update the display with the current counter value */
for(int i=0  ; i<16; i++){
  for(int j=0; j<4; j++){
  WriteNumberToSegment(j,i);
  //WriteNumberToSegment(3-j,i); //æ”¹å·¦ç§»ï¼Œå³ç§»ç›´æ¥æ”¾j
  delay(100);
  }
}
}

/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_MAP[Value]);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
## Q2-3.ino ä¸ƒæ®µé¡¯ç¤ºå™¨ç…§æŒ‰éµ 1ã€2ã€3ã€4 å¾€å³é¡¯ç¤ºç§»å‹•
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      shiftbuf(databuf,SEGMENT_MAP[1]);
    }
    if(!digitalRead(BUTTON2)){
      shiftbuf(databuf,SEGMENT_MAP[2]);
    }
    if(!digitalRead(BUTTON3)){
      shiftbuf(databuf,SEGMENT_MAP[3]);
    }
    if(!digitalRead(BUTTON4)){
      shiftbuf(databuf,SEGMENT_MAP[4]);
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# è§£æ±ºå½ˆè·³å•é¡Œï¼ŒæŒ‰ä¸‹BTNæ™‚æœƒå…ˆç­‰æŒ‰éˆ•æ”¾é–‹å¾Œæ‰ç¹¼çºŒå‹•ä½œ
```C
if(!digitalRead(BUTTON1)){
      delay(20);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
      //shiftbuf(databuf,SEGMENT_MAP[1]);
    }
```
## Q2-3.ino ä¸ƒæ®µé¡¯ç¤ºå™¨ç…§æŒ‰éµ 1ã€2ã€3ã€4 å¾€å³é¡¯ç¤ºç§»å‹•
## è§£æ±ºå½ˆè·³å•é¡Œï¼ŒæŒ‰ä¸‹BTNæ™‚æœƒå…ˆç­‰æŒ‰éˆ•æ”¾é–‹å¾Œæ‰ç¹¼çºŒå‹•ä½œ
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      delay(20);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
      //shiftbuf(databuf,SEGMENT_MAP[1]);
    }
    if(!digitalRead(BUTTON2)){
      delay(20);
        if(!digitalRead(BUTTON2))
        {
          shiftbuf(databuf,SEGMENT_MAP[2]);
          while(!digitalRead(BUTTON2));
        }
      //shiftbuf(databuf,SEGMENT_MAP[2]);
    }
    if(!digitalRead(BUTTON3)){
      delay(20);
        if(!digitalRead(BUTTON3))
        {
          shiftbuf(databuf,SEGMENT_MAP[3]);
          while(!digitalRead(BUTTON3));
        }
      //shiftbuf(databuf,SEGMENT_MAP[3]);
    }
    if(!digitalRead(BUTTON4)){
      delay(20);
        if(!digitalRead(BUTTON4))
        {
          shiftbuf(databuf,SEGMENT_MAP[4]);
          while(!digitalRead(BUTTON4));
        }
      //shiftbuf(databuf,SEGMENT_MAP[4]);
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
## Q2-3.ino ä¸ƒæ®µé¡¯ç¤ºå™¨ç…§æŒ‰éµ 1ã€2ã€3ã€4 å¾€å³é¡¯ç¤ºç§»å‹•
## è§£æ±ºå½ˆè·³å•é¡Œï¼ŒæŒ‰ä¸‹BTNæ™‚æœƒå…ˆç­‰æŒ‰éˆ•æ”¾é–‹å¾Œæ‰ç¹¼çºŒå‹•ä½œ
```C
/* Define shift register pins used for seven segment display */
#define LATCH_DIO D15   
#define CLK_DIO D14
#define DATA_DIO 2
#define BUTTON1 BT1
#define BUTTON2 BT2
#define BUTTON3 BT3
#define BUTTON4 BT4
#define BUTTON_A1 A1
#define BUTTON_A2 A2
#define BUTTON_A3 A3
/* Segment byte maps for numbers 0 to 9 , A, b , C*/
const byte SEGMENT_MAP[] = {0x3F,0x06,0x5b,0x4F,0x66,0x6D,0x7D,0x27,0X7F,0X67,0X77,0x7c,0x39,0X5e,0x79,0x71};

/* Byte maps to select digit 1 to 4 */
const byte SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7};
void setup ()
{
/* Set DIO pins to outputs */
pinMode(LATCH_DIO,OUTPUT);
pinMode(CLK_DIO,OUTPUT);
pinMode(DATA_DIO,OUTPUT);
}
/* Main program */
int cnt=0;
char databuf[]={0x00, 0x00, 0x0, 0x0};
void shiftbuf(char *buf, byte data)
{
  for(int i=0 ; i<3 ; i++){
    *(buf+i) = *(buf+i+1);
  }
  *(buf+3) = data;
}
void loop()
{
/* Update the display with the current counter value */
    unsigned long starttime=millis();
    while((millis()-starttime<100))
    {
      WriteNumberToSegment(0, databuf[0]);
      delay(2);
      WriteNumberToSegment(1, databuf[1]);
      delay(2);
      WriteNumberToSegment(2, databuf[2]);
      delay(2);
      WriteNumberToSegment(3, databuf[3]);
      delay(2);  
    }
    if(!digitalRead(BUTTON1)){
      delay(20);
        if(!digitalRead(BUTTON1))
        {
          shiftbuf(databuf,SEGMENT_MAP[1]);
          while(!digitalRead(BUTTON1));
        }
      //shiftbuf(databuf,SEGMENT_MAP[1]);
    }
    if(!digitalRead(BUTTON2)){
      delay(20);
        if(!digitalRead(BUTTON2))
        {
          shiftbuf(databuf,SEGMENT_MAP[2]);
          while(!digitalRead(BUTTON2));
        }
      //shiftbuf(databuf,SEGMENT_MAP[2]);
    }
    if(!digitalRead(BUTTON3)){
      delay(20);
        if(!digitalRead(BUTTON3))
        {
          shiftbuf(databuf,SEGMENT_MAP[3]);
          while(!digitalRead(BUTTON3));
        }
      //shiftbuf(databuf,SEGMENT_MAP[3]);
    }
    if(!digitalRead(BUTTON4)){
      delay(20);
        if(!digitalRead(BUTTON4))
        {
          shiftbuf(databuf,SEGMENT_MAP[4]);
          while(!digitalRead(BUTTON4));
        }
      //shiftbuf(databuf,SEGMENT_MAP[4]);
    }
}
/* Write a decimal number between 0 and 9 to one of the 4 digits of the display */
void WriteNumberToSegment(byte Segment, byte Value)
{
digitalWrite(LATCH_DIO,LOW);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, Value);
shiftOut(DATA_DIO, CLK_DIO, MSBFIRST, SEGMENT_SELECT[Segment] );
digitalWrite(LATCH_DIO,HIGH);
}
```
# `LCD_RTC.ino`
```C
/*
  LiquidCrystal Library
  The circuit:
 * LCD RS pin to digital pin 8
 * LCD Enable pin to digital pin 9
 * LCD D4 pin to digital pin 4
 * LCD D5 pin to digital pin 5
 * LCD D6 pin to digital pin 6
 * LCD D7 pin to digital pin 7
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
 */

// include the library code:
#include <LiquidCrystal.h>
#include <RTC.h>
 
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 5;
const byte hours = 14;
const byte day = 5;

void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2); //(è¡Œ,åˆ—)

     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
}

void loop() {
     lcd.clear();
     lcd.print("2021/05/");
     lcd.print(RTC.getday());
     lcd.print(",");
     lcd.setCursor(0, 1);
     
     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
     
     delay(1000);
}
```
# ç§»å‹• lcm 'è€ƒ'
# `LCD_RTCalarm.ino`
```C
/*
  LiquidCrystal Library
  The circuit:
 * LCD RS pin to digital pin 8
 * LCD Enable pin to digital pin 9
 * LCD D4 pin to digital pin 4
 * LCD D5 pin to digital pin 5
 * LCD D6 pin to digital pin 6
 * LCD D7 pin to digital pin 7
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
 */

// include the library code:
#include <LiquidCrystal.h>
#include <RTC.h>
//#include "rtc_drv.h"

/* RTC driver */
//RTC_Driver RTC_DRV = {DEV_RTC, 0};
// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

/* Change these values to set the current initial time */
const byte seconds = 0;
const byte minutes = 4;
const byte hours = 16;
const byte day = 15;
byte alarmminutes = 4;
byte alarmseconds = 10;
void setup() {
     // set up the LCD's number of columns and rows
     lcd.begin(16, 2);
     Serial.begin(115200);
     // set the time and start counting
     RTC.settime(day, hours, minutes, seconds);
     RTC.startcounting();
     RTC.setalarmcallbackfunc(alarm);
     RTC.setalarmtime(hours, minutes, alarmseconds);
     RTC.attachalarmint();
}

void loop() {
     lcd.clear();
     //lcd.print("Start Counting...");
     lcd.setCursor(0, 0);
     lcd.print("2021/5/");
     lcd.print(RTC.getday());
     lcd.print(",");
     lcd.print(RTC.gethours());
     lcd.print(":");
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds( ));
     delay(1000);
}

void alarm()
{
     lcd.setCursor(0, 1);
     lcd.print("                   ");
     lcd.setCursor(0, 1);
     lcd.print("alarm "); 
     lcd.print(RTC.getminutes());
     lcd.print(":");
     lcd.print(RTC.getseconds());
     delay(1000);
     alarmseconds += 5;
     if (alarmseconds >= 60)
        alarmminutes = RTC.getminutes()+1;
     else
        alarmminutes = RTC.getminutes(); 
     alarmseconds %= 60;
     RTC.setalarmtime(hours, alarmminutes, alarmseconds);        
     RTC.clearalarmst();  
}
```
## â— `Q4-2`
```C
/*******************************************************
This program will play as a piano.
********************************************************/
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
/*
 * '1' -> Do  * '2' -> Sol
 * '4' -> Re  * '5' -> La_H
 * '7' -> Mi  * '8' -> Si_H 
 * '*' -> Fa  * '0' -> Do_H
 */
unsigned int KeyValue[]={Do, Sol, Re, La_H, Mi, Si_H, Fa, Do_H};
//char KeyValue[]={'1','2','3','A','4','5','6','B','7','8','9','C','*','0','#','D'};
byte Row=0, Col=0;

void playNote(int OutputPin, unsigned int Note, unsigned long duration) {
  // æ’­æ”¾éŸ³ç¬¦å°æ‡‰çš„é »ç‡
     tone(OutputPin, Note, duration);
  //ä¸‹æ–¹çš„ delay() åŠ noTone ()ï¼Œæ¸¬è©¦éå¾Œä¸€å®šè¦æœ‰é€™å…©è¡Œï¼Œæ•´é«”çš„æ’¥æ”¾å‡ºä¾†çš„æ±è¥¿æ‰ä¸æœƒäº‚æ‰ï¼Œå¯èƒ½æ˜¯å› ç‚º Arduino é€å‡ºtone () é »ç‡å¾Œæœƒé¦¬ä¸Šæ¥è‘—åŸ·è¡Œä¸‹å€‹æŒ‡ä»¤ï¼Œä¸æœƒç­‰è²éŸ³æ’­å®Œï¼Œå°è‡´æ’¥å‡ºçš„è²éŸ³æ··åˆè€Œäº‚æ‰
     delay(duration*1.1);
   noTone(OutputPin);
}

void setup() {
  // put your setup code here, to run once:
  pinMode(10, INPUT); //R1: S1,S2,S3,S4 (1,2,3,A)                                   
  pinMode(11, INPUT_PULLUP); //R2: S5,S6,S7,S8 (4,5,6,B)
  pinMode(12, INPUT_PULLUP); //R3: S9, S10, S11,S12 (7,8,9,C)
  pinMode(13, INPUT_PULLUP); //R4: (*,0,#,D)
  pinMode(A0, OUTPUT); //A1, C1: S1,S5,S9 (1,4,7,*)
  pinMode(A1, OUTPUT); //A2, C2: S2,S6,S10 (2,5,8,0)
  pinMode(A2, OUTPUT); //A3, C3: S3,S7,S11 (3,6,9,#)
  pinMode(A3, OUTPUT); //A4, C4, S4,S8,S12 (*,0, #,D)
  //Pin left to right :R1 R2 R3 R4 C1 C2 C3 C4
  digitalWrite(A0,HIGH);
  digitalWrite(A1,HIGH);
  digitalWrite(A2,HIGH);
  digitalWrite(A3,HIGH);
} 

void loop() {
  // put your main code here, to run repeatedly:
  static int keypressedcount=0;
  byte keyindex=0;
  //if key is pressed in the first round scan, 
  //then call keyscan() again to check if the key pressed in first round is actually pressed 
  if(keyscan()==true) 
  {
    keyindex=(Row-1)*2+Col-1;
    delay(5);
    if ((keyscan()==true) && (keyindex==(Row-1)*2+Col-1))
    {
      playNote(D3,  KeyValue[keyindex], 300); 
    }
  } 
}

bool keyscan( )
{
  Row=0;Col=0;
  bool keypressed = false;
  //scan col1
  digitalWrite(A0, LOW);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A0, HIGH);
      Col=1;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A0, HIGH);
      Col=1;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col2
  digitalWrite(A0, HIGH);
  digitalWrite(A1, LOW);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A1, HIGH);
      Col=2;Row=4;
      keypressed = true;
      return(keypressed);
  }
  /*
  //scan col3
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, LOW);
  digitalWrite(A3, HIGH);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
      digitalWrite(A2, HIGH);
      Col=3;Row=4;
      keypressed = true;
      return(keypressed);
  }
  //scan col4
  digitalWrite(A0, HIGH);
  digitalWrite(A1, HIGH);
  digitalWrite(A2, HIGH);
  digitalWrite(A3, LOW);
  delayMicroseconds(100);
  //Read keys in row.1
  if(digitalRead(10)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=1;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.2
  if(digitalRead(11)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=2;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.3
  if(digitalRead(12)==LOW)
  {
      digitalWrite(A3, HIGH);
      Col=4;Row=3;
      keypressed = true;
      return(keypressed);
  }
  //Read keys in row.4
  if(digitalRead(13)==LOW)
  {
       digitalWrite(A3, HIGH);
      Col=4;Row=4;
      keypressed = true;
      return(keypressed);
  }
  */
  return(false);
}
```
## â— `Q4-3`
```C
#define Do ((unsigned int) 262)
#define Re ((unsigned int) 294)
#define Mi ((unsigned int) 330)
#define Fa ((unsigned int) 349)
#define Sol ((unsigned int) 392)
#define La_H ((unsigned int) 440)
#define Si_H ((unsigned int) 494)
#define Do_H ((unsigned int) 523)
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -| 
//|5 5 4 4| 3 3 2 -|5 5 4 4|3 3 2 -|
//|1 1 5 5| 6 6 5 -|4 4 3 3|2 2 1 -|
unsigned int melody[]={Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do, 
                       Sol, Sol, Fa, Fa, Mi, Mi, Re, Sol, Sol, Fa, Fa, Mi, Mi, Re,
                       Do,Do,Sol,Sol,La_H,La_H,Sol,Fa,Fa, Mi, Mi,Re,Re,Do};
unsigned int beat[]={1,1,1,1,1,1,2,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,2,1,1,1,1,1,1,2,
                     1,1,1,1,1,1,2,1,1,1,1,1,1,2};
int speakerPin = D3;
// ä¾ç…§ç°¡è­œçš„é †åºï¼Œå¡«å…¥ä»£è¡¨çš„éŸ³ç¬¦ï¼Œç©ºç™½ä»£è¡¨ä¼‘æ­¢ç¬¦
unsigned int notes[] = {Do, Re, Mi, Fa, Sol, La_H, Si_H, Do_H};
// åˆ©ç”¨ sizeof()ï¼Œç®—å‡ºç¸½å…±è¦å¤šå°‘éŸ³ç¬¦
int length = sizeof(melody) / sizeof(melody[0]);
// æ±ºå®šä¸€æ‹å¤šé•·ï¼Œé€™é‚Šä¸€æ‹ 300 ms
int tempo = 300;

void setup() {
  pinMode(speakerPin, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  // åˆ©ç”¨ for ä¾†æ’­æ”¾æˆ‘å€‘è¨­å®šçš„æ­Œæ›²ï¼Œä¸€å€‹éŸ³ä¸€å€‹éŸ³æ’¥æ”¾
  for (int i = 0; i < length; i++) {
   // å‘¼å« palyNote() é€™å€‹ functionï¼Œå°‡éŸ³ç¬¦è½‰æ›æˆè¨Šè™Ÿè®“èœ‚é³´å™¨ç™¼è²
      playNote(speakerPin, melody[i], tempo*beat[i]);
      Serial.print(notes[i]);Serial.println("Hz");
    // æ¯å€‹éŸ³ç¬¦ä¹‹é–“çš„é–“éš”ï¼Œé€™é‚Šè¨­å®šçš„é•·çŸ­æœƒæœ‰é€£éŸ³ or æ–·éŸ³çš„æ•ˆæœ
    //delay(tempo/10);
  }
  Serial.println("************************************");
  delay(2000);
}

void playNote(int OutputPin, unsigned int pitch, unsigned long duration) {
  // æ’­æ”¾éŸ³ç¬¦å°æ‡‰çš„é »ç‡
     tone(OutputPin,pitch, duration);
  //ä¸‹æ–¹çš„ delay() åŠ noTone ()ï¼Œæ¸¬è©¦éå¾Œä¸€å®šè¦æœ‰é€™å…©è¡Œï¼Œæ•´é«”çš„æ’¥æ”¾å‡ºä¾†çš„æ±è¥¿æ‰ä¸æœƒäº‚æ‰ï¼Œå¯èƒ½æ˜¯å› ç‚º Arduino é€å‡ºtone () é »ç‡å¾Œæœƒé¦¬ä¸Šæ¥è‘—åŸ·è¡Œä¸‹å€‹æŒ‡ä»¤ï¼Œä¸æœƒç­‰è²éŸ³æ’­å®Œï¼Œå°è‡´æ’¥å‡ºçš„è²éŸ³æ··åˆè€Œäº‚æ‰
     delay(duration*1.2);
   noTone(OutputPin);
}

```
## â— `ambulance`
```C
void setup() {
    
}

void loop() {
  ambulenceSiren(D3);
}

void ambulenceSiren(int pin) {
  tone(pin, 400);        
  delay(500);
  tone(pin, 800);        
  delay(500);
  noTone(pin);
  }
```
